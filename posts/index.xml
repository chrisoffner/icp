<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>Posts on Chris Offner</title>
        <link>https://chrisoffner.github.io/studynotes/posts/</link>
        <description>Recent content in Posts on Chris Offner</description>
        <generator>Hugo -- gohugo.io</generator>
        <language>en-us</language>
        <copyright>This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.</copyright>
        <lastBuildDate>Wed, 10 Nov 2021 11:48:27 +0100</lastBuildDate>
        <atom:link href="https://chrisoffner.github.io/studynotes/posts/index.xml" rel="self" type="application/rss+xml" />
        
        <item>
            <title>Another Reee test</title>
            <link>https://chrisoffner.github.io/studynotes/posts/2021/11/another-reee-test/</link>
            <pubDate>Wed, 10 Nov 2021 11:48:27 +0100</pubDate>
            
            <guid>https://chrisoffner.github.io/studynotes/posts/2021/11/another-reee-test/</guid>
            <description>ICP is used in Simultaneous Does this work and Mapping (SLAM) systems for LiDAR or RGBD data The algorithm is comprised of two steps:  Data association Let \cr(A, B\cr) be our point clouds. For each point $a_i \in A$ we perform a nearest-neighbour search among points $b_j \in B$ to find the point $b_j$ with closest distance to $a_i$. Transformation Align point clouds on top of each other. Compute centres of mass.</description>
            <content type="html"><![CDATA[<ul>
<li>ICP is used in Simultaneous Does this work and Mapping (SLAM) systems for LiDAR or RGBD data</li>
<li>The algorithm is comprised of two steps:
<ul>
<li><strong>Data association</strong>
Let \cr(A, B\cr) be our point clouds.
For each point $a_i \in A$ we perform a nearest-neighbour search among points $b_j \in B$ to find the point $b_j$ with closest distance to $a_i$.</li>
<li><strong>Transformation</strong>
Align point clouds on top of each other.
Compute centres of mass.
Compute rotation using Singular Value Decomposition (SVD).</li>
</ul>
</li>
</ul>
<p><strong>Variants of ICP</strong></p>
<ul>
<li><em>Point-to-plane</em> assumes that points are not independent points in space but have been sampled from a surface (plane?). Requires to leave SVD approach and use a general least-squares approach instead. Then use, for example, the Gauss-Newton method to minimise the error under this point-to-plane metric.</li>
<li><em>Projective ICP</em></li>
<li>robust kernels (?) to better deal with outliers</li>
</ul>
<h3 id="the-basic-alignment-problem">The basic alignment problem</h3>
<p>Given two input point sets $X = {x_1, &hellip;, x_I}, Y={y_1,&hellip;,y_J}$ with correspondences $C={(i,j)}$, we are looking for translation $t$ and rotation $R$ that minimise the sum of squared errors:</p>
<p>$$\sum_{(i,j)\in C} ||y_i - Rx_j - t||^2 \rightarrow \min$$</p>
<h3 id="simplified-correspondences">Simplified correspondences</h3>
<p>Reorder point clouds $X, Y$ given the correspondences $C$ using an index $n$.</p>
<p>Point sets ${x_n}, {y_n}$</p>
<p>Find the rigid body transform</p>
<p>$$\overline{x}_n = R x_n + t, \quad n\in{1,&hellip;, N}, N := |C|$$</p>
<p>that transforms points ${x_n}$ into ${\overline{x}_n}$ such that the point set ${\overline{x}_n}$ will be as close as possible to the point set ${y_n}$, i.e. minimising the sum of squared point-to-point distances.</p>
<h3 id="special-case-of-the-absolute-orientation-problem">Special case of the Absolute Orientation Problem</h3>
<p>In the absolute orientation problem, we look for the similarity transform</p>
<p>$$\overline{x}_n = \lambda R \bold{x}_n + \bold{t}$$</p>
<p>transforming 3D point sets, including a scaling factor $\lambda$. Here, we only need the rigid body transform, meaning we assume $\lambda = 1$.</p>
<h3 id="formal-problem-definition">Formal problem definition</h3>
<p>Given corresponding points $x_n, y_n, n \in {1,&hellip;, N}$</p>
<p>and optionally weights $p_n$</p>
<p>find the parameters $R, \bold{t}$ of the rigid body transform with</p>
<p>$$\overline{x}_n = R\bold{x}_n + \bold{t},\quad n\in{1,&hellip;,N}$$</p>
<p>such that the squared error is minimised</p>
<p>$$\sum ||\bold{y}_n - \bold{\overline{x}}_n||^2p_n \rightarrow \min$$</p>
<h3 id="direct-optimal-solutions-exists">Direct optimal solutions exists</h3>
<p>Assuming perfect known data association, a direct and optimal solution exists.</p>
<p><strong>Direct</strong>: no initial guess and no iteration required</p>
<p><strong>Optimal</strong>: no better solution exists</p>
<p>Informally speaking it</p>
<ul>
<li>computes a <em>shift</em> involving the <em>centres of mass</em> of both point clouds</li>
<li>performs a <em>rotational</em> alignment using SVD</li>
</ul>
<h3 id="direct-computation-of-the-rotation-matrix-r">Direct computation of the rotation matrix $R$</h3>
<p>$$\bold{x}_0 = \frac{\sum \bold{x}_np_n}{\sum p_n} \qquad \bold{y}_0 = \frac{\sum \bold{y}_np_n}{\sum p_n}$$</p>
<p>Use the weighted means of each point set to calculate a so-called <strong>cross-covariance (or cross-correlation) matrix $H$:</strong></p>
<p>$$H = \sum(\bold{y}_n - \bold{y}_0)(\bold{x}_n - \bold{x}_0)^T p_n$$</p>
<p>And then we decompose $H$ into three matrices $U, D,$ and $V.$</p>
<p>$$\mathrm{svd}(H) = UDV^T$$</p>
<p>The rotation matrix we&rsquo;re looking for is</p>
<p>$$R = VU^T$$</p>
<h3 id="direct-computation-of-the-translation-vector-boldt">Direct computation of the translation vector $\bold{t}$</h3>
<p>$$t = \bold{y}_0 - R\bold{x}_0$$</p>
<h3 id="svd-based-alignment">SVD-based alignment</h3>
<p>Compute mean-reduced coordinates</p>
<ul>
<li>$\bold{a}_n = (\bold{y}_n - \bold{y}_0)$</li>
<li>$\bold{b}_n = (\bold{x}_n - \bold{x}_0)$</li>
</ul>
<p>Compute cross-covariance matrix</p>
<ul>
<li>$H = \sum \bold{a}_n \bold{b}_n^T p_n$</li>
</ul>
<p>Compute SVD</p>
<ul>
<li>$\mathrm{svd(H)} = UDV^T$</li>
</ul>
<p>Rotation matrix is given by</p>
<ul>
<li>$R = UV^T$ (which one is correct, this or the one above??)</li>
</ul>
<p>Translation vector is given by</p>
<ul>
<li>$t = y_0 - Rx_0$</li>
</ul>
<p>Translate and rotate points</p>
<ul>
<li>$\overline{x}_n=R x_n + t$</li>
</ul>
<h2 id="derivation">Derivation</h2>
<h3 id="use-local-coordinate-system">Use local coordinate system</h3>
<p>We want to use local coordinates defined by the point set ${y_n}$</p>
<p>We set the origin as the weighted mean of ${y_n}$ computed by</p>
<p>$$y_0 = \frac{\sum y_np_n}{\sum p_n}$$</p>
<p>such that we minimise</p>
<p>$$\sum ||y_n - y_0 - Rx_n - t + y_0||^2 p_n \rightarrow \min$$</p>
<h3 id="rewrite-translation-vector">Rewrite translation vector</h3>
<p>Start with $\overline{x}_n = Rx_n+t$ and use the shift of the origin $\overline{x}_n - y_0 = Rx_n + t - y_0$ to rewrite the translation vector. Here we exploit the fact that for rotation matrices, $R R^T = I$:</p>
<p>$$‚Åç$$</p>
<p>Introduce a <em><strong>new variable</strong></em> $x_0 = R^T y_0-R^Tt:$</p>
<p>$$\overline{x}_n-y_0 = R(x_n-x_0)$$</p>
<h3 id="minimisation">Minimisation</h3>
<p>Initially formulated problem:</p>
<p>$$\sum || y_n - \overline{x}_n||^2p_n \rightarrow \min$$</p>
<p>turns into</p>
<p>$$\sum || y_n - y_0 - R(x_n - x_0)||^2p_n \rightarrow \min$$</p>
<p>We need to find $R^<em>, x_0^</em>$ such that</p>
<p>$$R^<em>, x_0^</em> = \argmin_{R, x_0}\sum || y_n - y_0 - R(x_n - x_0)||^2p_n$$</p>
<p>Computation:</p>
<p>$$\begin{align*}
\Phi(x_0, R) \coloneqq \sum &amp;\left[ (y_n -y_0) - R(x_n - x_0) \right]^T\cr&amp;\left[ (y_n -y_0) - R(x_n - x_0) \right]p_n\cr
= \sum &amp;(y_n-y_0)^T(y_n-y_0)p_n &amp;&amp; \text{(no $R, x_0$)}\cr</p>
<ul>
<li>\sum &amp;(x_n-x_0)^T(x_n-x_0)p_n&amp;&amp; \text{(no $R$)}\cr</li>
</ul>
<ul>
<li>2\sum &amp;(y_n-y_0)^TR(x_n-x_0)p_n
\end{align*}$$</li>
</ul>
<h3 id="minimise-with-regard-to-x_0">Minimise with regard to $x_0$</h3>
<p>$$\begin{aligned}\frac{\partial\Phi(x_0, R)}{\partial x_0} = &amp;-2\sum(x_n - x_0)p_n\cr\cr&amp;+2\sum R^T(y_n-y_0)p_n\end{aligned}$$</p>
<p>Setting the first derivative to zero simplifies this to:</p>
<p>$$\sum(x_n - x_0)p_n = R^T\sum (y_n-y_0)p_n$$</p>
<p>The right side of this equals zero because $y_0$ is the weighted mean of $y_n$.</p>
<p>$$\begin{aligned}
0 = &amp;\sum(x_n-x_0)p_n\cr
= &amp;\sum x_np_n - x_0\sum p_n
\end{aligned}$$</p>
<p>This leads to</p>
<p>$$x_0 = \frac{\sum x_np_n}{\sum p_n}$$</p>
<p>which means <strong>the optimal value for $x_0$ is the weighted mean of the points</strong> $x_n$.</p>
<h3 id="minimise-with-regard-to-r">Minimise with regard to $R$</h3>
<p>Only the third term of $\Phi(x_0, R)$ depends on $R.$ We therefore need to find the $R$ that maximises</p>
<p>$$\sum (y_n-y_0)^TR(x_n-x_0)p_n$$</p>
<p>with the constraint $R^TR = I$.</p>
<p>Compute mean-reduced coordinates</p>
<ul>
<li>$\bold{b}_n = (\bold{y}_n - \bold{y}_0)$</li>
<li>$\bold{a}_n = (\bold{x}_n - \bold{x}_0)$</li>
</ul>
<p>This leads to the compact form</p>
<p>$$\sum b_n^TRa_np_n$$</p>
<h3 id="rewrite-using-the-trace">Rewrite using the trace</h3>
<p>$$\begin{align*}
R^* = &amp;\argmax_R \sum b_n^TRa_np_n\cr
= &amp;\argmax_R \mathrm{tr}(RH)
\end{align*}$$</p>
<p>with the cross-covariance matrix $H = \sum(a_nb_n^T)p_n$</p>
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<p>Thus we need to find $R$ that maximises $\mathrm{tr}(RH)$</p>
<h3 id="maximisation-using-svd">Maximisation using SVD</h3>
<p>$$\mathrm{svd}(H) = UDV^T$$</p>
<p>with  $U^TU = I,\quad V^TV=I,\quad D=\mathrm{diag}(d_i)$.</p>
<h1 id="resources">Resources</h1>
<h3 id="icp-lectures">ICP lectures</h3>
<p><a href="https://www.youtube.com/watch?v=QWDM4cFdKrE">Iterative Closest Point (ICP) - 5 Minutes with Cyrill</a></p>
<p><a href="https://www.youtube.com/watch?v=dhzLQfDBx2Q">ICP &amp; Point Cloud Registration - Part 1: Known Data Association &amp; SVD (Cyrill Stachniss, 2021)</a></p>
<p><a href="https://www.youtube.com/watch?v=ktRqKxddjJk">ICP &amp; Point Cloud Registration - Part 2: Unknown Data Association (Cyrill Stachniss, 2021)</a></p>
<p><a href="https://www.youtube.com/watch?v=CJE59i8oxIE">ICP &amp; Point Cloud Registration - Part 3: Non-linear Least Squares (Cyrill Stachniss, 2021)</a></p>
<p><a href="https://www.youtube.com/watch?v=2hC9IG6MFD0">Point-to-Plane and Generalized ICP - 5 Minutes with Cyrill</a></p>
<h3 id="svd-lectures">SVD lectures</h3>
<p><a href="https://www.youtube.com/playlist?list=PLMrJAkhIeNNSVjnsviglFoY2nXildDCcv">Singular Value Decomposition</a></p>
<h3 id="papers">Papers</h3>
<p><a href="Iterative%20Closest%20Point%20(ICP)%20Algorithm%2020211195965c45b5b3af81743be4477f/On_the_ICP_Algorithm.pdf">On the ICP Algorithm.pdf</a></p>
<p><a href="Iterative%20Closest%20Point%20(ICP)%20Algorithm%2020211195965c45b5b3af81743be4477f/Worst-case_and_Smoothed_Analysis_of_the_ICP_Algorithm_with_an_Application_to_the_k-means_Method.pdf">Worst-case and Smoothed Analysis of the ICP Algorithm, with an Application to the k-means Method.pdf</a></p>
<p><a href="Iterative%20Closest%20Point%20(ICP)%20Algorithm%2020211195965c45b5b3af81743be4477f/Provably_Approximated_ICP.pdf">Provably Approximated ICP.pdf</a></p>
<p><a href="Iterative%20Closest%20Point%20(ICP)%20Algorithm%2020211195965c45b5b3af81743be4477f/Efficient_Variants_of_the_ICP_Algorithm.pdf">Efficient Variants of the ICP Algorithm.pdf</a></p>
<p><a href="Iterative%20Closest%20Point%20(ICP)%20Algorithm%2020211195965c45b5b3af81743be4477f/Geometrically_Stable_Sampling_for_the_ICP_Algorithm.pdf">Geometrically Stable Sampling for the ICP Algorithm.pdf</a></p>
]]></content>
        </item>
        
        <item>
            <title>First Post</title>
            <link>https://chrisoffner.github.io/studynotes/posts/2021/11/first-post/</link>
            <pubDate>Wed, 10 Nov 2021 11:48:27 +0100</pubDate>
            
            <guid>https://chrisoffner.github.io/studynotes/posts/2021/11/first-post/</guid>
            <description>&lt;p&gt;This is my first post testing Hugo.&lt;/p&gt;</description>
            <content type="html"><![CDATA[<p>This is my first post testing Hugo.</p>
<h2 id="testing-h2-headers">Testing H2 headers</h2>
<p>This is just a default body paragraph to see how the typography looks. Inline code looks like <code>print(&quot;Hello World!&quot;)</code>.
I can make things <em>italic</em> and <strong>bold</strong> if needed.</p>
<blockquote>
<p>Quotes look like this.</p>
</blockquote>
<h3 id="h3-headers-are-also-supported">H3 headers are also supported.</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-swift" data-lang="swift"><span style="color:#66d9ef">import</span> <span style="color:#a6e22e">SwiftUI</span>

<span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">MyView</span>: View {
    <span style="color:#66d9ef">var</span> body: some View {
        Text(<span style="color:#e6db74">&#34;Hello Hugo!&#34;</span>)
    }
}
</code></pre></div><h2 id="mathjax-looks-like-this">MathJax looks like this</h2>
<p>$$\frac{x^2}{\sum_{i=0}^\infty x^i}$$</p>]]></content>
        </item>
        
        <item>
            <title>Introduction to ICP</title>
            <link>https://chrisoffner.github.io/studynotes/posts/2021/11/introduction-to-icp/</link>
            <pubDate>Wed, 10 Nov 2021 11:48:27 +0100</pubDate>
            
            <guid>https://chrisoffner.github.io/studynotes/posts/2021/11/introduction-to-icp/</guid>
            <description>ICP is used in Simultaneous Localisation and Mapping (SLAM) systems for LiDAR or RGBD data The algorithm is comprised of two steps:  Data association Let $A, B$ be our point clouds. For each point $a_i \in A$ we perform a nearest-neighbour search among points $b_j \in B$ to find the point $b_j$ with closest distance to $a_i$. Transformation Align point clouds on top of each other. Compute centres of mass.</description>
            <content type="html"><![CDATA[<ul>
<li>ICP is used in Simultaneous Localisation and Mapping (SLAM) systems for LiDAR or RGBD data</li>
<li>The algorithm is comprised of two steps:
<ul>
<li><strong>Data association</strong>
Let $A, B$ be our point clouds.
For each point $a_i \in A$ we perform a nearest-neighbour search among points $b_j \in B$ to find the point $b_j$ with closest distance to $a_i$.</li>
<li><strong>Transformation</strong>
Align point clouds on top of each other.
Compute centres of mass.
Compute rotation using Singular Value Decomposition (SVD).</li>
</ul>
</li>
</ul>
<p><strong>Variants of ICP</strong></p>
<ul>
<li><em>Point-to-plane</em> assumes that points are not independent points in space but have been sampled from a surface (plane?). Requires to leave SVD approach and use a general least-squares approach instead. Then use, for example, the Gauss-Newton method to minimise the error under this point-to-plane metric.</li>
<li><em>Projective ICP</em></li>
<li>robust kernels (?) to better deal with outliers</li>
</ul>
<h3 id="the-basic-alignment-problem">The basic alignment problem</h3>
<p>Given two input point sets $X = {x_1, &hellip;, x_I}, Y={y_1,&hellip;,y_J}$ with correspondences $C={(i,j)}$, we are looking for translation $t$ and rotation $R$ that minimise the sum of squared errors:</p>
<p>$$\sum_{(i,j)\in C} ||y_i - Rx_j - t||^2 \rightarrow \min$$</p>
<h3 id="simplified-correspondences">Simplified correspondences</h3>
<p>Reorder point clouds $X, Y$ given the correspondences $C$ using an index $n$.</p>
<p>Point sets ${x_n}, {y_n}$</p>
<p>Find the rigid body transform</p>
<p>$$\overline{x}_n = R x_n + t, \quad n\in{1,&hellip;, N}, N := |C|$$</p>
<p>that transforms points ${x_n}$ into ${\overline{x}_n}$ such that the point set ${\overline{x}_n}$ will be as close as possible to the point set ${y_n}$, i.e. minimising the sum of squared point-to-point distances.</p>
<h3 id="special-case-of-the-absolute-orientation-problem">Special case of the Absolute Orientation Problem</h3>
<p>In the absolute orientation problem, we look for the similarity transform</p>
<p>$$\overline{x}_n = \lambda R \bold{x}_n + \bold{t}$$</p>
<p>transforming 3D point sets, including a scaling factor $\lambda$. Here, we only need the rigid body transform, meaning we assume $\lambda = 1$.</p>
<h3 id="formal-problem-definition">Formal problem definition</h3>
<p>Given corresponding points $x_n, y_n, n \in {1,&hellip;, N}$</p>
<p>and optionally weights $p_n$</p>
<p>find the parameters $R, \bold{t}$ of the rigid body transform with</p>
<p>$$\overline{x}_n = R\bold{x}_n + \bold{t},\quad n\in{1,&hellip;,N}$$</p>
<p>such that the squared error is minimised</p>
<p>$$\sum ||\bold{y}_n - \bold{\overline{x}}_n||^2p_n \rightarrow \min$$</p>
<h3 id="direct-optimal-solutions-exists">Direct optimal solutions exists</h3>
<p>Assuming perfect known data association, a direct and optimal solution exists.</p>
<p><strong>Direct</strong>: no initial guess and no iteration required</p>
<p><strong>Optimal</strong>: no better solution exists</p>
<p>Informally speaking it</p>
<ul>
<li>computes a <em>shift</em> involving the <em>centres of mass</em> of both point clouds</li>
<li>performs a <em>rotational</em> alignment using SVD</li>
</ul>
<h3 id="direct-computation-of-the-rotation-matrix-r">Direct computation of the rotation matrix $R$</h3>
<p>$$\bold{x}_0 = \frac{\sum \bold{x}_np_n}{\sum p_n} \qquad \bold{y}_0 = \frac{\sum \bold{y}_np_n}{\sum p_n}$$</p>
<p>Use the weighted means of each point set to calculate a so-called <strong>cross-covariance (or cross-correlation) matrix $H$:</strong></p>
<p>$$H = \sum(\bold{y}_n - \bold{y}_0)(\bold{x}_n - \bold{x}_0)^T p_n$$</p>
<p>And then we decompose $H$ into three matrices $U, D,$ and $V.$</p>
<p>$$\mathrm{svd}(H) = UDV^T$$</p>
<p>The rotation matrix we&rsquo;re looking for is</p>
<p>$$R = VU^T$$</p>
<h3 id="direct-computation-of-the-translation-vector-boldt">Direct computation of the translation vector $\bold{t}$</h3>
<p>$$t = \bold{y}_0 - R\bold{x}_0$$</p>
<h3 id="svd-based-alignment">SVD-based alignment</h3>
<p>Compute mean-reduced coordinates</p>
<ul>
<li>$\bold{a}_n = (\bold{y}_n - \bold{y}_0)$</li>
<li>$\bold{b}_n = (\bold{x}_n - \bold{x}_0)$</li>
</ul>
<p>Compute cross-covariance matrix</p>
<ul>
<li>$H = \sum \bold{a}_n \bold{b}_n^T p_n$</li>
</ul>
<p>Compute SVD</p>
<ul>
<li>$\mathrm{svd(H)} = UDV^T$</li>
</ul>
<p>Rotation matrix is given by</p>
<ul>
<li>$R = UV^T$ (which one is correct, this or the one above??)</li>
</ul>
<p>Translation vector is given by</p>
<ul>
<li>$t = y_0 - Rx_0$</li>
</ul>
<p>Translate and rotate points</p>
<ul>
<li>$\overline{x}_n=R x_n + t$</li>
</ul>
<h2 id="derivation">Derivation</h2>
<h3 id="use-local-coordinate-system">Use local coordinate system</h3>
<p>We want to use local coordinates defined by the point set ${y_n}$</p>
<p>We set the origin as the weighted mean of ${y_n}$ computed by</p>
<p>$$y_0 = \frac{\sum y_np_n}{\sum p_n}$$</p>
<p>such that we minimise</p>
<p>$$\sum ||y_n - y_0 - Rx_n - t + y_0||^2 p_n \rightarrow \min$$</p>
<h3 id="rewrite-translation-vector">Rewrite translation vector</h3>
<p>Start with $\overline{x}_n = Rx_n+t$ and use the shift of the origin $\overline{x}_n - y_0 = Rx_n + t - y_0$ to rewrite the translation vector. Here we exploit the fact that for rotation matrices, $R R^T = I$:</p>
<p>$$‚Åç$$</p>
<p>Introduce a <em><strong>new variable</strong></em> $x_0 = R^T y_0-R^Tt:$</p>
<p>$$\overline{x}_n-y_0 = R(x_n-x_0)$$</p>
<h3 id="minimisation">Minimisation</h3>
<p>Initially formulated problem:</p>
<p>$$\sum || y_n - \overline{x}_n||^2p_n \rightarrow \min$$</p>
<p>turns into</p>
<p>$$\sum || y_n - y_0 - R(x_n - x_0)||^2p_n \rightarrow \min$$</p>
<p>We need to find $R^*, x_0^*$ such that</p>
<p>$$R^*, x_0^* = \argmin_{R, x_0}\sum || y_n - y_0 - R(x_n - x_0)||^2p_n$$</p>
<p>Computation:</p>
<p>$$\begin{aligned}\Phi(x_0, R) \coloneqq \sum &amp;\left[ (y_n -y_0) - R(x_n - x_0) \right]^T\&amp;\left[ (y_n -y_0) - R(x_n - x_0) \right]p_n\cr= \sum &amp;(y_n-y_0)^T(y_n-y_0)p_n &amp;&amp; \text{(no $R, x_0$)}\cr+ \sum &amp;(x_n-x_0)^T(x_n-x_0)p_n&amp;&amp; \text{(no $R$)}\cr- 2\sum &amp;(y_n-y_0)^TR(x_n-x_0)p_n\end{aligned}$$</p>
<h3 id="minimise-with-regard-to-x_0">Minimise with regard to $x_0$</h3>
<p>$$\begin{aligned}
\frac{\partial\Phi(x_0, R)}{\partial x_0} = &amp;-2\sum(x_n - x_0)p_n\cr
&amp;+2\sum R^T(y_n-y_0)p_n
\end{aligned}$$</p>
<p>Setting the first derivative to zero simplifies this to:</p>
<p>$$\sum(x_n - x_0)p_n = R^T\sum (y_n-y_0)p_n$$</p>
<p>The right side of this equals zero because $y_0$ is the weighted mean of $y_n$.</p>
<p>$$\begin{aligned}
0 = &amp;\sum(x_n-x_0)p_n\cr
= &amp;\sum x_np_n - x_0\sum p_n
\end{aligned}$$</p>
<p>This leads to</p>
<p>$$x_0 = \frac{\sum x_np_n}{\sum p_n}$$</p>
<p>which means <strong>the optimal value for $x_0$ is the weighted mean of the points</strong> $x_n$.</p>
<h3 id="minimise-with-regard-to-r">Minimise with regard to $R$</h3>
<p>Only the third term of $\Phi(x_0, R)$ depends on $R.$ We therefore need to find the $R$ that maximises</p>
<p>$$\sum (y_n-y_0)^TR(x_n-x_0)p_n$$</p>
<p>with the constraint $R^TR = I$.</p>
<p>Compute mean-reduced coordinates</p>
<ul>
<li>$\bold{b}_n = (\bold{y}_n - \bold{y}_0)$</li>
<li>$\bold{a}_n = (\bold{x}_n - \bold{x}_0)$</li>
</ul>
<p>This leads to the compact form</p>
<p>$$\sum b_n^TRa_np_n$$</p>
<h3 id="rewrite-using-the-trace">Rewrite using the trace</h3>
<p>$$\begin{aligned}
R^* = &amp;\argmax_R \sum b_n^TRa_np_n\cr
= &amp;\argmax_R \mathrm{tr}(RH)
\end{aligned}$$</p>
<p>with the cross-covariance matrix $H = \sum(a_nb_n^T)p_n$</p>
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<p>Thus we need to find $R$ that maximises $\mathrm{tr}(RH)$</p>
<h3 id="maximisation-using-svd">Maximisation using SVD</h3>
<p>$$\mathrm{svd}(H) = UDV^T$$</p>
<p>with  $U^TU = I,\quad V^TV=I,\quad D=\mathrm{diag}(d_i)$.</p>
<h1 id="resources">Resources</h1>
<h3 id="icp-lectures">ICP lectures</h3>
<p><a href="https://www.youtube.com/watch?v=">Iterative Closest Point (ICP) - 5 Minutes with Cyrill</a>

<div style="position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden;">
  <iframe src="https://www.youtube.com/embed/QWDM4cFdKrE" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; border:0;" allowfullscreen title="Iterative Closest Point (ICP) - 5 Minutes with Cyrill"></iframe>
</div>
</p>
<hr>
<p><a href="https://www.youtube.com/watch?v=dhzLQfDBx2Q">ICP &amp; Point Cloud Registration - Part 1: Known Data Association &amp; SVD (Cyrill Stachniss, 2021)</a></p>

<div style="position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden;">
  <iframe src="https://www.youtube.com/embed/dhzLQfDBx2Q" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; border:0;" allowfullscreen title="ICP &amp; Point Cloud Registration - Part 1: Known Data Association &amp; SVD (Cyrill Stachniss, 2021)"></iframe>
</div>

<hr>
<p><a href="https://www.youtube.com/watch?v=ktRqKxddjJk">ICP &amp; Point Cloud Registration - Part 2: Unknown Data Association (Cyrill Stachniss, 2021)</a></p>

<div style="position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden;">
  <iframe src="https://www.youtube.com/embed/ktRqKxddjJk" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; border:0;" allowfullscreen title="YouTube Video"></iframe>
</div>

<hr>
<p><a href="https://www.youtube.com/watch?v=CJE59i8oxIE">ICP &amp; Point Cloud Registration - Part 3: Non-linear Least Squares (Cyrill Stachniss, 2021)</a></p>

<div style="position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden;">
  <iframe src="https://www.youtube.com/embed/CJE59i8oxIE" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; border:0;" allowfullscreen title="YouTube Video"></iframe>
</div>

<hr>
<p><a href="https://www.youtube.com/watch?v=2hC9IG6MFD0">Point-to-Plane and Generalized ICP - 5 Minutes with Cyrill</a></p>

<div style="position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden;">
  <iframe src="https://www.youtube.com/embed/2hC9IG6MFD0" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; border:0;" allowfullscreen title="YouTube Video"></iframe>
</div>

<hr>
<h3 id="svd-lectures">SVD lectures</h3>
<p><a href="https://www.youtube.com/playlist?list=PLMrJAkhIeNNSVjnsviglFoY2nXildDCcv">Singular Value Decomposition</a></p>
<h3 id="papers">Papers</h3>
<p><a href="Iterative%20Closest%20Point%20(ICP)%20Algorithm%2020211195965c45b5b3af81743be4477f/On_the_ICP_Algorithm.pdf">On the ICP Algorithm.pdf</a></p>
<p><a href="Iterative%20Closest%20Point%20(ICP)%20Algorithm%2020211195965c45b5b3af81743be4477f/Worst-case_and_Smoothed_Analysis_of_the_ICP_Algorithm_with_an_Application_to_the_k-means_Method.pdf">Worst-case and Smoothed Analysis of the ICP Algorithm, with an Application to the k-means Method.pdf</a></p>
<p><a href="Iterative%20Closest%20Point%20(ICP)%20Algorithm%2020211195965c45b5b3af81743be4477f/Provably_Approximated_ICP.pdf">Provably Approximated ICP.pdf</a></p>
<p><a href="Iterative%20Closest%20Point%20(ICP)%20Algorithm%2020211195965c45b5b3af81743be4477f/Efficient_Variants_of_the_ICP_Algorithm.pdf">Efficient Variants of the ICP Algorithm.pdf</a></p>
<p><a href="Iterative%20Closest%20Point%20(ICP)%20Algorithm%2020211195965c45b5b3af81743be4477f/Geometrically_Stable_Sampling_for_the_ICP_Algorithm.pdf">Geometrically Stable Sampling for the ICP Algorithm.pdf</a></p>
]]></content>
        </item>
        
        <item>
            <title>Iterative Closest Point (ICP) Algorithm</title>
            <link>https://chrisoffner.github.io/studynotes/posts/2021/11/iterative-closest-point-icp-algorithm/</link>
            <pubDate>Wed, 10 Nov 2021 11:48:27 +0100</pubDate>
            
            <guid>https://chrisoffner.github.io/studynotes/posts/2021/11/iterative-closest-point-icp-algorithm/</guid>
            <description>ICP is used in Simultaneous Localisation and Mapping (SLAM) systems for LiDAR or RGBD data The algorithm is comprised of two steps:  Data association Let \(A, B\) be our point clouds. For each point \(a_i \in A\) we perform a nearest-neighbour search among points \(b_j \in B\) to find the point \(b_j\) with closest distance to \(a_i\). Transformation Align point clouds on top of each other. Compute centres of mass.</description>
            <content type="html"><![CDATA[<ul>
<li>ICP is used in Simultaneous Localisation and Mapping (SLAM) systems for LiDAR or RGBD data</li>
<li>The algorithm is comprised of two steps:
<ul>
<li><strong>Data association</strong>
Let \(A, B\) be our point clouds.
For each point \(a_i \in A\) we perform a nearest-neighbour search among points \(b_j \in B\) to find the point \(b_j\) with closest distance to \(a_i\).</li>
<li><strong>Transformation</strong>
Align point clouds on top of each other.
Compute centres of mass.
Compute rotation using Singular Value Decomposition (SVD).</li>
</ul>
</li>
</ul>
<p><strong>Variants of ICP</strong></p>
<ul>
<li><em>Point-to-plane</em> assumes that points are not independent points in space but have been sampled from a surface (plane?). Requires to leave SVD approach and use a general least-squares approach instead. Then use, for example, the Gauss-Newton method to minimise the error under this point-to-plane metric.</li>
<li><em>Projective ICP</em></li>
<li>robust kernels (?) to better deal with outliers</li>
</ul>
<h3 id="the-basic-alignment-problem">The basic alignment problem</h3>
<p>Given two input point sets \(X = {x_1, &hellip;, x_I}, Y={y_1,&hellip;,y_J}\) with correspondences \(C={(i,j)}\), we are looking for translation \(t\) and rotation \(R\) that minimise the sum of squared errors:</p>
<p>$$\sum_{(i,j)\in C} ||y_i - Rx_j - t||^2 \rightarrow \min$$</p>
<h3 id="simplified-correspondences">Simplified correspondences</h3>
<p>Reorder point clouds \(X, Y\) given the correspondences \(C\) using an index \(n\).</p>
<p>Point sets \({x_n}, {y_n}\)</p>
<p>Find the rigid body transform</p>
<p>$$\overline{x}_n = R x_n + t, \quad n\in{1,&hellip;, N}, N := |C|$$</p>
<p>that transforms points \({x_n}\) into \({\overline{x}_n}\) such that the point set \({\overline{x}_n}\) will be as close as possible to the point set \({y_n}\), i.e. minimising the sum of squared point-to-point distances.</p>
<h3 id="special-case-of-the-absolute-orientation-problem">Special case of the Absolute Orientation Problem</h3>
<p>In the absolute orientation problem, we look for the similarity transform</p>
<p>$$\overline{x}_n = \lambda R \bold{x}_n + \bold{t}$$</p>
<p>transforming 3D point sets, including a scaling factor \(\lambda\). Here, we only need the rigid body transform, meaning we assume \(\lambda = 1\).</p>
<h3 id="formal-problem-definition">Formal problem definition</h3>
<p>Given corresponding points \(x_n, y_n, n \in {1,&hellip;, N}\)</p>
<p>and optionally weights \(p_n\)</p>
<p>find the parameters \(R, \bold{t}\) of the rigid body transform with</p>
<p>$$\overline{x}_n = R\bold{x}_n + \bold{t},\quad n\in{1,&hellip;,N}$$</p>
<p>such that the squared error is minimised</p>
<p>$$\sum ||\bold{y}_n - \bold{\overline{x}}_n||^2p_n \rightarrow \min$$</p>
<h3 id="direct-optimal-solutions-exists">Direct optimal solutions exists</h3>
<p>Assuming perfect known data association, a direct and optimal solution exists.</p>
<p><strong>Direct</strong>: no initial guess and no iteration required</p>
<p><strong>Optimal</strong>: no better solution exists</p>
<p>Informally speaking it</p>
<ul>
<li>computes a <em>shift</em> involving the <em>centres of mass</em> of both point clouds</li>
<li>performs a <em>rotational</em> alignment using SVD</li>
</ul>
<h3 id="direct-computation-of-the-rotation-matrix-r">Direct computation of the rotation matrix \(R\)</h3>
<p>$$\bold{x}_0 = \frac{\sum \bold{x}_np_n}{\sum p_n} \qquad \bold{y}_0 = \frac{\sum \bold{y}_np_n}{\sum p_n}$$</p>
<p>Use the weighted means of each point set to calculate a so-called <strong>cross-covariance (or cross-correlation) matrix \(H\):</strong></p>
<p>$$H = \sum(\bold{y}_n - \bold{y}_0)(\bold{x}_n - \bold{x}_0)^T p_n$$</p>
<p>And then we decompose \(H\) into three matrices \(U, D,\) and \(V.\)</p>
<p>$$\mathrm{svd}(H) = UDV^T$$</p>
<p>The rotation matrix we&rsquo;re looking for is</p>
<p>$$R = VU^T$$</p>
<h3 id="direct-computation-of-the-translation-vector--boldt">Direct computation of the translation vector  \(\bold{t}\)</h3>
<p>$$t = \bold{y}_0 - R\bold{x}_0$$</p>
<h3 id="svd-based-alignment">SVD-based alignment</h3>
<p>Compute mean-reduced coordinates</p>
<ul>
<li>\(\bold{a}_n = (\bold{y}_n - \bold{y}_0)\)</li>
<li>\(\bold{b}_n = (\bold{x}_n - \bold{x}_0)\)</li>
</ul>
<p>Compute cross-covariance matrix</p>
<ul>
<li>\(H = \sum \bold{a}_n \bold{b}_n^T p_n\)</li>
</ul>
<p>Compute SVD</p>
<ul>
<li>\(\mathrm{svd(H)} = UDV^T\)</li>
</ul>
<p>Rotation matrix is given by</p>
<ul>
<li>\(R = UV^T\) (which one is correct, this or the one above??)</li>
</ul>
<p>Translation vector is given by</p>
<ul>
<li>\(t = y_0 - Rx_0\)</li>
</ul>
<p>Translate and rotate points</p>
<ul>
<li>\(\overline{x}_n=R x_n + t\)</li>
</ul>
<h2 id="derivation">Derivation</h2>
<h3 id="use-local-coordinate-system">Use local coordinate system</h3>
<p>We want to use local coordinates defined by the point set \({y_n}\)</p>
<p>We set the origin as the weighted mean of \({y_n}\) computed by</p>
<p>$$y_0 = \frac{\sum y_np_n}{\sum p_n}$$</p>
<p>such that we minimise</p>
<p>$$\sum ||y_n - y_0 - Rx_n - t + y_0||^2 p_n \rightarrow \min$$</p>
<h3 id="rewrite-translation-vector">Rewrite translation vector</h3>
<p>Start with \(\overline{x}_n = Rx_n+t\) and use the shift of the origin \(\overline{x}_n - y_0 = Rx_n + t - y_0\) to rewrite the translation vector. Here we exploit the fact that for rotation matrices, \(R R^T = I\):</p>
<p>$$\overline{x}_n -y_0 = R(x_n + R^Tt-R^Ty_0)$$</p>
<p>Introduce a <em><strong>new variable</strong></em> \(x_0 = R^T y_0-R^Tt:\)</p>
<p>$$\overline{x}_n-y_0 = R(x_n-x_0)$$</p>
<h3 id="minimisation">Minimisation</h3>
<p>Initially formulated problem:</p>
<p>$$\sum || y_n - \overline{x}_n||^2p_n \rightarrow \min$$</p>
<p>turns into</p>
<p>$$\sum || y_n - y_0 - R(x_n - x_0)||^2p_n \rightarrow \min$$</p>
<p>We need to find \(R^*, x_0^*\) such that</p>
<p>$$R^*, x_0^* = \argmin_{R, x_0}\sum || y_n - y_0 - R(x_n - x_0)||^2p_n$$</p>
<p>Computation:</p>
<p>$$\begin{aligned}\Phi(x_0, R) \coloneqq \sum &amp; (y_n -y_0) - R(x_n - x_0) ^T\\&amp; (y_n -y_0) - R(x_n - x_0) p_n\\= \sum &amp;(y_n-y_0)^T(y_n-y_0)p_n &amp;&amp; \text{(no \(R, x_0\))}\\+ \sum &amp;(x_n-x_0)^T(x_n-x_0)p_n&amp;&amp; \text{(no \(R\))}\\- 2\sum &amp;(y_n-y_0)^TR(x_n-x_0)p_n\end{aligned}$$</p>
<h3 id="minimise-with-regard-to-x_0">Minimise with regard to \(x_0\)</h3>
<p>$$\begin{aligned}\frac{\partial\Phi(x_0, R)}{\partial x_0} = &amp;-2\sum(x_n - x_0)p_n\\&amp;+2\sum R^T(y_n-y_0)p_n\end{aligned}$$</p>
<p>Setting the first derivative to zero simplifies this to:</p>
<p>$$\sum(x_n - x_0)p_n = R^T\sum (y_n-y_0)p_n$$</p>
<p>The right side of this equals zero because \(y_0\) is the weighted mean of \(y_n\).</p>
<p>$$\begin{aligned}0 = &amp;\sum(x_n-x_0)p_n\\= &amp;\sum x_np_n - x_0\sum p_n\end{aligned}$$</p>
<p>This leads to</p>
<p>$$x_0 = \frac{\sum x_np_n}{\sum p_n}$$</p>
<p>which means <strong>the optimal value for \(x_0\) is the weighted mean of the points</strong> \(x_n\).</p>
<h3 id="minimise-with-regard-to-r">Minimise with regard to \(R\)</h3>
<p>Only the third term of \(\Phi(x_0, R)\) depends on \(R.\) We therefore need to find the \(R\) that maximises</p>
<p>$$\sum (y_n-y_0)^TR(x_n-x_0)p_n$$</p>
<p>with the constraint \(R^TR = I\).</p>
<p>Compute mean-reduced coordinates</p>
<ul>
<li>\(\bold{b}_n = (\bold{y}_n - \bold{y}_0)\)</li>
<li>\(\bold{a}_n = (\bold{x}_n - \bold{x}_0)\)</li>
</ul>
<p>This leads to the compact form</p>
<p>$$\sum b_n^TRa_np_n$$</p>
<h3 id="rewrite-using-the-trace">Rewrite using the trace</h3>
<p>$$\begin{aligned}
R^* = &amp;\argmax_R \sum b_n^TRa_np_n\\= &amp;\argmax_R \mathrm{tr}(RH)\end{aligned}$$</p>
<p>with the cross-covariance matrix \(H = \sum(a_nb_n^T)p_n\)</p>
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<p>Thus we need to find \(R\) that maximises \(\mathrm{tr}(RH)\)</p>
<h3 id="maximisation-using-svd">Maximisation using SVD</h3>
<p>$$\mathrm{svd}(H) = UDV^T$$</p>
<p>with  \(U^TU = I,\quad V^TV=I,\quad D=\mathrm{diag}(d_i)\).</p>
<h1 id="resources">Resources</h1>
<h3 id="icp-lectures">ICP lectures</h3>
<p><a href="https://www.youtube.com/watch?v=QWDM4cFdKrE">Iterative Closest Point (ICP) - 5 Minutes with Cyrill</a></p>
<p><a href="https://www.youtube.com/watch?v=dhzLQfDBx2Q">ICP &amp; Point Cloud Registration - Part 1: Known Data Association &amp; SVD (Cyrill Stachniss, 2021)</a></p>
<p><a href="https://www.youtube.com/watch?v=ktRqKxddjJk">ICP &amp; Point Cloud Registration - Part 2: Unknown Data Association (Cyrill Stachniss, 2021)</a></p>
<p><a href="https://www.youtube.com/watch?v=CJE59i8oxIE">ICP &amp; Point Cloud Registration - Part 3: Non-linear Least Squares (Cyrill Stachniss, 2021)</a></p>
<p><a href="https://www.youtube.com/watch?v=2hC9IG6MFD0">Point-to-Plane and Generalized ICP - 5 Minutes with Cyrill</a></p>
<h3 id="svd-lectures">SVD lectures</h3>
<p><a href="https://www.youtube.com/playlist?list=PLMrJAkhIeNNSVjnsviglFoY2nXildDCcv">Singular Value Decomposition</a></p>
<h3 id="papers">Papers</h3>
<p><a href="Iterative%20Closest%20Point%20(ICP)%20Algorithm%2020211195965c45b5b3af81743be4477f/On_the_ICP_Algorithm.pdf">On the ICP Algorithm.pdf</a></p>
<p><a href="Iterative%20Closest%20Point%20(ICP)%20Algorithm%2020211195965c45b5b3af81743be4477f/Worst-case_and_Smoothed_Analysis_of_the_ICP_Algorithm_with_an_Application_to_the_k-means_Method.pdf">Worst-case and Smoothed Analysis of the ICP Algorithm, with an Application to the k-means Method.pdf</a></p>
<p><a href="Iterative%20Closest%20Point%20(ICP)%20Algorithm%2020211195965c45b5b3af81743be4477f/Provably_Approximated_ICP.pdf">Provably Approximated ICP.pdf</a></p>
<p><a href="Iterative%20Closest%20Point%20(ICP)%20Algorithm%2020211195965c45b5b3af81743be4477f/Efficient_Variants_of_the_ICP_Algorithm.pdf">Efficient Variants of the ICP Algorithm.pdf</a></p>
<p><a href="Iterative%20Closest%20Point%20(ICP)%20Algorithm%2020211195965c45b5b3af81743be4477f/Geometrically_Stable_Sampling_for_the_ICP_Algorithm.pdf">Geometrically Stable Sampling for the ICP Algorithm.pdf</a></p>
]]></content>
        </item>
        
    </channel>
</rss>
